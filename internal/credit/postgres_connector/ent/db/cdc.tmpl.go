// Code generated by ent, DO NOT EDIT.

package db

import (
	"context"

	"entgo.io/ent"
)

// CDCIDs returns the ids of the records that were affected by the mutation with any type, so that
// the cdc engine can fetch those.
func (m *CreditEntryMutation) CDCIDs(ctx context.Context) ([]any, error) {
	// The m.IDs() only return data for other mutations, but not OpCreate, so let's handle it
	// as an exception case.
	if m.Op() == ent.OpCreate {
		id, exists := m.ID()
		if !exists {
			return nil, nil
		}
		return []any{id}, nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return nil, err
	}

	res := make([]any, len(ids))
	for idx, id := range ids {
		res[idx] = id
	}

	return res, nil
}

// CDCIDs returns the ids of the records that were affected by the mutation with any type, so that
// the cdc engine can fetch those.
func (m *FeatureMutation) CDCIDs(ctx context.Context) ([]any, error) {
	// The m.IDs() only return data for other mutations, but not OpCreate, so let's handle it
	// as an exception case.
	if m.Op() == ent.OpCreate {
		id, exists := m.ID()
		if !exists {
			return nil, nil
		}
		return []any{id}, nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return nil, err
	}

	res := make([]any, len(ids))
	for idx, id := range ids {
		res[idx] = id
	}

	return res, nil
}

// CDCIDs returns the ids of the records that were affected by the mutation with any type, so that
// the cdc engine can fetch those.
func (m *LedgerMutation) CDCIDs(ctx context.Context) ([]any, error) {
	// The m.IDs() only return data for other mutations, but not OpCreate, so let's handle it
	// as an exception case.
	if m.Op() == ent.OpCreate {
		id, exists := m.ID()
		if !exists {
			return nil, nil
		}
		return []any{id}, nil
	}

	ids, err := m.IDs(ctx)
	if err != nil {
		return nil, err
	}

	res := make([]any, len(ids))
	for idx, id := range ids {
		res[idx] = id
	}

	return res, nil
}
