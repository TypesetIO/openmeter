// Code generated by github.com/jmattheis/goverter, DO NOT EDIT.
//go:build !goverter

package api

import filter "github.com/openmeterio/openmeter/pkg/filter"

type ConverterImpl struct{}

func (c *ConverterImpl) ConvertFilterFloat(source *filter.FilterFloat) *FilterFloat {
	var pApiFilterFloat *FilterFloat
	if source != nil {
		apiFilterFloat := c.filterFilterFloatToApiFilterFloat((*source))
		pApiFilterFloat = &apiFilterFloat
	}
	return pApiFilterFloat
}
func (c *ConverterImpl) ConvertFilterInteger(source *filter.FilterInteger) *FilterInteger {
	var pApiFilterInteger *FilterInteger
	if source != nil {
		apiFilterInteger := c.filterFilterIntegerToApiFilterInteger((*source))
		pApiFilterInteger = &apiFilterInteger
	}
	return pApiFilterInteger
}
func (c *ConverterImpl) ConvertFilterString(source *filter.FilterString) *FilterString {
	var pApiFilterString *FilterString
	if source != nil {
		apiFilterString := c.filterFilterStringToApiFilterString((*source))
		pApiFilterString = &apiFilterString
	}
	return pApiFilterString
}
func (c *ConverterImpl) ConvertFilterTime(source *filter.FilterTime) *FilterTime {
	var pApiFilterTime *FilterTime
	if source != nil {
		apiFilterTime := c.filterFilterTimeToApiFilterTime((*source))
		pApiFilterTime = &apiFilterTime
	}
	return pApiFilterTime
}
func (c *ConverterImpl) filterFilterFloatToApiFilterFloat(source filter.FilterFloat) FilterFloat {
	var apiFilterFloat FilterFloat
	if source.And != nil {
		var apiFilterFloatList []FilterFloat
		if (*source.And) != nil {
			apiFilterFloatList = make([]FilterFloat, len((*source.And)))
			for i := 0; i < len((*source.And)); i++ {
				apiFilterFloatList[i] = c.filterFilterFloatToApiFilterFloat((*source.And)[i])
			}
		}
		apiFilterFloat.And = &apiFilterFloatList
	}
	apiFilterFloat.Eq = source.Eq
	apiFilterFloat.Gt = source.Gt
	apiFilterFloat.Gte = source.Gte
	apiFilterFloat.Lt = source.Lt
	apiFilterFloat.Lte = source.Lte
	apiFilterFloat.Ne = source.Ne
	if source.Or != nil {
		var apiFilterFloatList2 []FilterFloat
		if (*source.Or) != nil {
			apiFilterFloatList2 = make([]FilterFloat, len((*source.Or)))
			for j := 0; j < len((*source.Or)); j++ {
				apiFilterFloatList2[j] = c.filterFilterFloatToApiFilterFloat((*source.Or)[j])
			}
		}
		apiFilterFloat.Or = &apiFilterFloatList2
	}
	return apiFilterFloat
}
func (c *ConverterImpl) filterFilterIntegerToApiFilterInteger(source filter.FilterInteger) FilterInteger {
	var apiFilterInteger FilterInteger
	if source.And != nil {
		var apiFilterIntegerList []FilterInteger
		if (*source.And) != nil {
			apiFilterIntegerList = make([]FilterInteger, len((*source.And)))
			for i := 0; i < len((*source.And)); i++ {
				apiFilterIntegerList[i] = c.filterFilterIntegerToApiFilterInteger((*source.And)[i])
			}
		}
		apiFilterInteger.And = &apiFilterIntegerList
	}
	apiFilterInteger.Eq = source.Eq
	apiFilterInteger.Gt = source.Gt
	apiFilterInteger.Gte = source.Gte
	apiFilterInteger.Lt = source.Lt
	apiFilterInteger.Lte = source.Lte
	apiFilterInteger.Ne = source.Ne
	if source.Or != nil {
		var apiFilterIntegerList2 []FilterInteger
		if (*source.Or) != nil {
			apiFilterIntegerList2 = make([]FilterInteger, len((*source.Or)))
			for j := 0; j < len((*source.Or)); j++ {
				apiFilterIntegerList2[j] = c.filterFilterIntegerToApiFilterInteger((*source.Or)[j])
			}
		}
		apiFilterInteger.Or = &apiFilterIntegerList2
	}
	return apiFilterInteger
}
func (c *ConverterImpl) filterFilterStringToApiFilterString(source filter.FilterString) FilterString {
	var apiFilterString FilterString
	if source.And != nil {
		var apiFilterStringList []FilterString
		if (*source.And) != nil {
			apiFilterStringList = make([]FilterString, len((*source.And)))
			for i := 0; i < len((*source.And)); i++ {
				apiFilterStringList[i] = c.filterFilterStringToApiFilterString((*source.And)[i])
			}
		}
		apiFilterString.And = &apiFilterStringList
	}
	apiFilterString.Eq = source.Eq
	apiFilterString.Gt = source.Gt
	apiFilterString.Gte = source.Gte
	apiFilterString.Ilike = source.Ilike
	apiFilterString.In = source.In
	apiFilterString.Like = source.Like
	apiFilterString.Lt = source.Lt
	apiFilterString.Lte = source.Lte
	apiFilterString.Ne = source.Ne
	apiFilterString.Nilike = source.Nilike
	apiFilterString.Nin = source.Nin
	apiFilterString.Nlike = source.Nlike
	if source.Or != nil {
		var apiFilterStringList2 []FilterString
		if (*source.Or) != nil {
			apiFilterStringList2 = make([]FilterString, len((*source.Or)))
			for j := 0; j < len((*source.Or)); j++ {
				apiFilterStringList2[j] = c.filterFilterStringToApiFilterString((*source.Or)[j])
			}
		}
		apiFilterString.Or = &apiFilterStringList2
	}
	return apiFilterString
}
func (c *ConverterImpl) filterFilterTimeToApiFilterTime(source filter.FilterTime) FilterTime {
	var apiFilterTime FilterTime
	if source.And != nil {
		var apiFilterTimeList []FilterTime
		if (*source.And) != nil {
			apiFilterTimeList = make([]FilterTime, len((*source.And)))
			for i := 0; i < len((*source.And)); i++ {
				apiFilterTimeList[i] = c.filterFilterTimeToApiFilterTime((*source.And)[i])
			}
		}
		apiFilterTime.And = &apiFilterTimeList
	}
	apiFilterTime.Gt = source.Gt
	apiFilterTime.Gte = source.Gte
	apiFilterTime.Lt = source.Lt
	apiFilterTime.Lte = source.Lte
	if source.Or != nil {
		var apiFilterTimeList2 []FilterTime
		if (*source.Or) != nil {
			apiFilterTimeList2 = make([]FilterTime, len((*source.Or)))
			for j := 0; j < len((*source.Or)); j++ {
				apiFilterTimeList2[j] = c.filterFilterTimeToApiFilterTime((*source.Or)[j])
			}
		}
		apiFilterTime.Or = &apiFilterTimeList2
	}
	return apiFilterTime
}
